<!doctype html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Interrupts, Spin Locks and Preemptioninterrupts Process context vs. interrupt context  system calls run in process context- can sleep Interrupt handlers run in interrupt context - cannot sleep Reason:">
<meta property="og:type" content="article">
<meta property="og:title" content="Spin Locks">
<meta property="og:url" content="http://yoursite.com/2017/05/19/Spin-Locks/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Interrupts, Spin Locks and Preemptioninterrupts Process context vs. interrupt context  system calls run in process context- can sleep Interrupt handlers run in interrupt context - cannot sleep Reason:">
<meta property="og:image" content="http://i.imgur.com/2AYSHLS.png">
<meta property="og:image" content="http://i.imgur.com/CESWHvr.png">
<meta property="og:image" content="http://i.imgur.com/WK925dv.png">
<meta property="og:image" content="http://i.imgur.com/0sOQDvd.png">
<meta property="og:image" content="http://i.imgur.com/kZ83ZJ6.png">
<meta property="og:updated_time" content="2017-05-19T20:31:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spin Locks">
<meta name="twitter:description" content="Interrupts, Spin Locks and Preemptioninterrupts Process context vs. interrupt context  system calls run in process context- can sleep Interrupt handlers run in interrupt context - cannot sleep Reason:">
<meta name="twitter:image" content="http://i.imgur.com/2AYSHLS.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/05/19/Spin-Locks/"/>





  <title>Spin Locks | Hexo</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/19/Spin-Locks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Spin Locks</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-19T16:31:10-04:00">
                2017-05-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Interrupts-Spin-Locks-and-Preemption"><a href="#Interrupts-Spin-Locks-and-Preemption" class="headerlink" title="Interrupts, Spin Locks and Preemption"></a>Interrupts, Spin Locks and Preemption</h1><h4 id="interrupts"><a href="#interrupts" class="headerlink" title="interrupts"></a>interrupts</h4><ul>
<li><p>Process context vs. interrupt context</p>
<ul>
<li>system calls run in process context- can sleep</li>
<li>Interrupt handlers run in interrupt context - cannot sleep<ul>
<li>Reason: when in interrupt context, there is no notion of the current process, so it does not save much info, so it is difficult to come back if gets put to the wait queue and switched to some other process</li>
<li>corollary: if you are in interrupt context, need to get out as quickly as possible</li>
</ul>
</li>
</ul>
</li>
<li><p>Interrupt handlers</p>
<ul>
<li>single interrupt will not next, so handler need to be reentrant<ul>
<li>but handler can be interrupted by a different interrupt</li>
</ul>
</li>
<li>only time critical stuff in handlers<ul>
<li>push rest to bottom half</li>
</ul>
</li>
<li>all handlers share one interrupt stack per processor</li>
<li>while handling a certain interrupt, that interrupt is disabled, but not the case for other interrupts</li>
</ul>
</li>
</ul>
<h4 id="Spin-Locks"><a href="#Spin-Locks" class="headerlink" title="Spin Locks"></a>Spin Locks</h4><ul>
<li><code>test_and_set()</code> hardware atomic instruction</li>
<li><p><code>spin_lock()</code> /<code>spin_unlock()</code></p>
<ul>
<li>must not lose CPU while holding a spin lock<ul>
<li>other threads will wait for the lock for a long time</li>
</ul>
</li>
<li><code>spin+lock()</code> prevents kernel preemption by ++preempt_count<ul>
<li>in uniprocessor, that’s all spin_lock() does</li>
<li>kernel preemption: even in kernel execution, a process can be switched out of a CPU</li>
</ul>
</li>
<li>must NOT call any function that can potentially sleep<ul>
<li><code>kmalloc</code>, <code>copy_from_user</code></li>
<li>solution: can allocate before hand and then assign the value within the critical section</li>
<li><code>kfree()</code> is safe to call because it does not sleep, but can be always taken out of the critical section</li>
</ul>
</li>
<li>hardware interrupt is ok unless the interrupt handler may try to lock this spin lock<ul>
<li>spin lock not recursive: same thread locking twice will deadlock</li>
</ul>
</li>
<li>keep the critical section as small as possible</li>
</ul>
</li>
<li><p>Critical regions not only contains merely incrementing a variable, it also spans multiple functions. That’s why we need a more general method os synchronization: locks. (In addition to making incrementing operations atomic)</p>
</li>
<li>A spin lock is a lock that can be held by at most one thread of execution.<ul>
<li>If a thread of execution attempts to acquire a spin lock while it is contended, the thread busy loops – spins – waiting for the lock to become available. Thus prevents more than one thread of execution from entering the critical region at any one time.</li>
<li>A contended spin lock causes threads to spin while waiting for the lock to become available is salient, so it is not wise to hold a spin lock for a long time.<ul>
<li>Nature of spin lock: a lightweight single-holder lock that should be held for short durations.</li>
<li>Alternative: sleep lock, put the current thread to sleep and wake it up when it becomes available. Then the processor can go off and execute other code. This incurs a bit of overhead – like a semaphore does.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Spin-Lock-Methods"><a href="#Spin-Lock-Methods" class="headerlink" title="Spin Lock Methods"></a>Spin Lock Methods</h4><ul>
<li>Spin locks are architecture-dependent and implemented in assembly. The architecture-dependent code is defined in <asm spinlock.h="">. The actual usable interfaces are defined in <linux spinlock.h="">. The basic use of a spin lock is:</linux></asm></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DEFINE_SPINLOCK(mr_lock);</div><div class="line">spin_lock(&amp;mr_lock);</div><div class="line"><span class="comment">/* critical region*/</span></div><div class="line">spin_unlock(&amp;mr_lock);</div></pre></td></tr></table></figure>
<ul>
<li>Has to be on multiprocessor machines and kernel preempt has to be on.</li>
<li><p>Linux kernel’s spin locks are not recursive. Meaning cannot try to obtain the lock you already hold!</p>
</li>
<li><p>Spin locks can be used in interrupt handlers, whereas semaphores cannot be used because they sleep.</p>
<ul>
<li>When used in an interrupt handler, must disable local interrupts before obtaining the lock. Otherwise, it is possible for an interrupt handler to interrupt kernel code while the lock is held and attempt to reacquire the lock. The interrupt handler spins, waiting for the lock to become available. The lock holder, however, does not run until the interrupt handler completes.</li>
<li>You only need to disable interrupts only on the current processor. If an interrupt occurs on a different processor, and it spins on the same lock, it does not prevent the lock holder releasing the lock.</li>
</ul>
</li>
<li>The kernel provides an interface that conveniently disables interrupts and acquires the lock. Usage:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DEFINE_SPINLOCK(mr_lock);</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line">spin_lock_irqsave(&amp;mr_lock, flags);</div><div class="line"><span class="comment">/*critical region ... */</span></div><div class="line">spin_unlock_irqrestore(&amp;mr_lock, flags);</div></pre></td></tr></table></figure>
<p><code>spin_lock_irqsave()</code> saves the current state of interrupts, disables them locally, and then obtains the given lock. Conversely, <code>spin_unlock_irqrestore()</code> unlocks the given lock and returns interrupts to their previous state. This way, if interrputs were initially disables, your code would not erroneously enable them, but instead keep them disables. <em>flags</em> variable is passed by value because the lock routines are implemented partially as macros.</p>
<ul>
<li>only have to call these version of spin lock when dealing with some global stuff like taking a task list from the task structs</li>
</ul>
<h4 id="Other-Spin-Lock-Methods"><a href="#Other-Spin-Lock-Methods" class="headerlink" title="Other Spin Lock Methods"></a>Other Spin Lock Methods</h4><p><code>spin_lock_init()</code>: initializes a dynamically created spin lock<br><code>spin_trylock()</code> attempts to obtain the given spin lock. If the lock is contended, rather than spin and wait for the lock to be released, the function immediately returns zero. If is succeeds in obtaining the lock, it returns nonzero<br><code>spin_islocked()</code> returns nonzero is the given lock is currently acquired. Otherwise it returns zero.</p>
<p>Complete List of standard spin lock methods:<br><img src="http://i.imgur.com/2AYSHLS.png" alt="Imgur"></p>
<h4 id="Spin-locks-and-Bottom-Halves"><a href="#Spin-locks-and-Bottom-Halves" class="headerlink" title="Spin locks and Bottom Halves"></a>Spin locks and Bottom Halves</h4><ul>
<li>certain locking precautions must be taken when working with bottom halves. The function <code>spin_lock_bh()</code> obtains the given lock and disables all bottom halves. <code>spin_unlock_bh()</code> performs the inverse.</li>
</ul>
<h4 id="Reader-Writer-Spin-locks"><a href="#Reader-Writer-Spin-locks" class="headerlink" title="Reader-Writer Spin locks"></a>Reader-Writer Spin locks</h4><ul>
<li>writing demands mutual exclusion, while reading, it is only important that nothing else writes to the same area.</li>
<li>reader/writer locks are sometimes called <em>shared/exlusinve</em> or <em>concurrent/exclusive locks</em> because the lock is available in a shared (for readers) and an exclusive (for writers) form.</li>
</ul>
<p>Usage:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">DEFINE_RWLOCK(&amp;mr_rwlock);</div><div class="line"><span class="comment">// Then in the reader code path:</span></div><div class="line">read_lock(&amp;mr_rwlock);</div><div class="line"><span class="comment">/*critical section (read only) ... */</span></div><div class="line">read_unlock(&amp;mr_rwlock);</div><div class="line"><span class="comment">// in the writer code path:</span></div><div class="line">write_lock(&amp;mr_rwlock);</div><div class="line"><span class="comment">/*critical section  (read and write)...*/</span></div><div class="line">write_unlock(&amp;mr_lock);</div></pre></td></tr></table></figure>
<ul>
<li>Assumes readers and writers are in entirely separate code paths, such as in the example above.</li>
<li>cannot “upgrade” a read lock to a write lock, which will result in deadlock, like the following code:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">read_lock(&amp;mr_rwlock);</div><div class="line">write_lock(&amp;mr_rwlock);</div></pre></td></tr></table></figure>
<p>Reader_writer spin lock methods:<br><img src="http://i.imgur.com/CESWHvr.png" alt="Imgur"></p>
<p>Plus the following three methods:<br><code>write_unlock_irqrestore()</code>: Releases given lock and restores local interrupts to given previous state<br><code>write_trylock()</code>: Tries to acquire given lock for writing; if unavailable, returns nonzero<br><code>rwlock_init()</code>: Initializes given <code>rwlock_t</code></p>
<ul>
<li>Linux reader_writer spin locks favors readers over writers. If the read lock is held and a writer is waiting for exclusive access, readers that attempt to acquire the lock continue to succeed. The spinning writer does not acquire the lock until all readers release the lock. Therefore, a sufficient number of readers can starve pending writers.</li>
</ul>
<h4 id="Semaphore-and-mutex"><a href="#Semaphore-and-mutex" class="headerlink" title="Semaphore and mutex"></a>Semaphore and mutex</h4><p>The simplicity and efficiency of the mutex comes from the additional constraints it imposes on its users over and above what the semaphore requires. Unlike a semaphore, which implements the most basic of behavior in accordance with Dijkstra’s original design, the mutex has a stricter, narrower use case:</p>
<ul>
<li>Only one task can hold the mutex at a time. That is, the usage count on a mutex is always one.</li>
<li>Whoever locked a mutex must unlock is. That is, you cannot lock a mutex in one context and then unlock it in another. This means that the mutex isn’t suitable for more complicated synchronizations between kernel and user-space. Most use cases cleanly lock and unlock from the same context.</li>
<li>Recursive locks and unlocks are not allowed. That is, you cannot recursively acquire the same mutex, and you cannot unlock an unlocked mutex.</li>
<li>A process cannot exit while holding a mutex.</li>
<li>A mutex cannot be acquired by an interrupt handler or bottom half, even with mutex_trylock()</li>
<li>A mutex can be managed only via the official API: It must be initialized via the methods described in this section and cannot be copies, hand initialized, or reinitialized.</li>
</ul>
<h4 id="Semaphores-VS-Mutexes"><a href="#Semaphores-VS-Mutexes" class="headerlink" title="Semaphores VS Mutexes"></a>Semaphores VS Mutexes</h4><ul>
<li>the formula dictating which to use is quite simple: Unless one of mutex’s additional constraints prevent you from using them, prefer the new mutex type to semaphores. When writing new code, only specific, often low-level, uses need a semaphore.</li>
</ul>
<h4 id="Spin-Locks-Versus-Mutexes"><a href="#Spin-Locks-Versus-Mutexes" class="headerlink" title="Spin Locks Versus Mutexes"></a>Spin Locks Versus Mutexes</h4><p><img src="http://i.imgur.com/WK925dv.png" alt="Imgur"></p>
<h4 id="Completion-Variables"><a href="#Completion-Variables" class="headerlink" title="Completion Variables"></a>Completion Variables</h4><p>Using <em>completion variables</em> is an easy way to synchronize between two tasks in the kernel when one task needs to signal to the other that an event has occurred.</p>
<ul>
<li>One task waits on the completion variable while another task performs some work. When the other task has completed the work, it uses the completion variable to wake up any waiting tasks. Much like a semaphore.<ul>
<li>The vfork() system call uses completion variables to wake up the parent process when the child process execs or exits.</li>
</ul>
</li>
<li>represented by the <code>struct completion</code> type, defined in <code>&lt;linux/completion.h&gt;</code>. A statically created completion variable is created and initialized via<br><code>DECLARE_COMLETION(mr_comp);</code><br>or<br><code>init_completion()</code> for dynamic allocation</li>
<li>On a given completion variable, the tasks that want to wait call <code>wait_for_completion()</code>. After the event has occurred, calling <code>complete()</code> signals all waiting tasks to wake up.</li>
</ul>
<p>completion variable methods:<br><img src="http://i.imgur.com/0sOQDvd.png" alt="Imgur"></p>
<ul>
<li>For sample usages of completion variables, see <strong>kernel/sched.c</strong> and <strong>kernel/fork.c</strong>.</li>
</ul>
<h4 id="BKL-The-Big-Kernel-Locks"><a href="#BKL-The-Big-Kernel-Locks" class="headerlink" title="BKL: The Big Kernel Locks"></a>BKL: The Big Kernel Locks</h4><p>BKL is a global spin lock that was created to ease the transition from Linux’s original SMP implementation to fine_grained locking.</p>
<h4 id="Sequential-Locks"><a href="#Sequential-Locks" class="headerlink" title="Sequential Locks"></a>Sequential Locks</h4><p>The <em>sequential lock</em>, generally shortened to <em>seq lock</em>, is a newer type of lock introduced in the 2.6 kernel. It provides a simple mechanism for reading and writing shared data. It works by maintaining a sequence counter. Whenever the data in question is written to, a lock is obtained and a sequence number is incremented. Prior to and after reading the data, the sequence number is read. If the values are the same, a write did not begin in the middle of the read. Further, if the values are even, a write is not underway.</p>
<ul>
<li>More details, LKD P200</li>
</ul>
<h4 id="Preemption-Disabling"><a href="#Preemption-Disabling" class="headerlink" title="Preemption Disabling"></a>Preemption Disabling</h4><p><strong>Kernel preemption</strong>: Kernel preemption is a method used mainly in monolithic and hybrid kernels where all or most device drivers are run in kernel space, whereby the scheduler is permitted to forcibly perform a context switch (i.e. preemptively schedule; on behalf of a runnable and higher priority process) on a driver or other part of the kernel during its execution, rather than co-operatively waiting for the driver or kernel function (such as a system call) to complete its execution and return control of the processor to the scheduler.</p>
<ul>
<li><p>Because the kernel is preemptive, a process in the kernel can stop running at any instant to enable a process of higher priority to run. This means a task can begin running in the same critical region as a task that was preempted. To prevent this, the kernel preemption code uses spin locks as markers of nonpreemptive regions. If a spin lock is held, the kernel is not preemptive. Because the concurrency issues with kernel preemption and SMP are the same, and the kernel is already SMP-safe; this simple change makes the kernel preempt-safe, too.</p>
</li>
<li><p>In reality, some situations do not require a spin lock, but do need kernel preemption disabled. The most frequent of these situations is per-processor data. If the data is unique to each processor, there might be no need to protect it with a lock because only that one processor can access the data. If no spin locks are held, the kernel is preemptive, and it would be possible for a newly scheduled task to access this same variable.</p>
</li>
<li><p>To solve this, kernel preemption can be disabled via <code>preempt_disable()</code>. The call is nestable; you can call it any number of times. For each call, a corresponding call to <code>preempt_enable()</code> is required. The final corresponding call to <code>preempt_enable()</code> reenables preemtion. eg:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">preempt_disable();</div><div class="line"><span class="comment">/*preemption is disabled...*/</span></div><div class="line">preempt_enable();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>The preemption count stores the number of held locks and <code>preempt_diable()</code> calls. If the number is zero, the kernel is preemptive. If the value is one or greater, the kernel is not preemptive. This count is incredibly useful – it is a great way to do atomicity and sleep debugging. The function <code>preempt_count()</code> returns this value.</p>
<p>Kernel Preemption-Related Methods:<br><img src="http://i.imgur.com/kZ83ZJ6.png" alt="Imgur"></p>
<p>As a cleaner solution to per-processor data issues, you can obtain the processor number (which presumably is used to index into the per-processor data) via <code>get_cpu()</code>. This function disables kernel preemption prior to returning the current processor number:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> cpu;</div><div class="line"></div><div class="line"><span class="comment">/*disable kernel preemption and set "cpu" to the current processor*/</span></div><div class="line">cpu = get_cpu();</div><div class="line"></div><div class="line"><span class="comment">/*manipulate per-processor data...*/</span></div><div class="line"><span class="comment">/*reenable kernel preemption, "cpu" can change and so is no longer value*/</span></div><div class="line">put_cpu();</div></pre></td></tr></table></figure></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/05/15/test-my-site/" rel="next" title="test_my_site">
                <i class="fa fa-chevron-left"></i> test_my_site
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Interrupts-Spin-Locks-and-Preemption"><span class="nav-number">1.</span> <span class="nav-text">Interrupts, Spin Locks and Preemption</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#interrupts"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">interrupts</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spin-Locks"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">Spin Locks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spin-Lock-Methods"><span class="nav-number">1.0.0.3.</span> <span class="nav-text">Spin Lock Methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Other-Spin-Lock-Methods"><span class="nav-number">1.0.0.4.</span> <span class="nav-text">Other Spin Lock Methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spin-locks-and-Bottom-Halves"><span class="nav-number">1.0.0.5.</span> <span class="nav-text">Spin locks and Bottom Halves</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reader-Writer-Spin-locks"><span class="nav-number">1.0.0.6.</span> <span class="nav-text">Reader-Writer Spin locks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore-and-mutex"><span class="nav-number">1.0.0.7.</span> <span class="nav-text">Semaphore and mutex</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphores-VS-Mutexes"><span class="nav-number">1.0.0.8.</span> <span class="nav-text">Semaphores VS Mutexes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spin-Locks-Versus-Mutexes"><span class="nav-number">1.0.0.9.</span> <span class="nav-text">Spin Locks Versus Mutexes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Completion-Variables"><span class="nav-number">1.0.0.10.</span> <span class="nav-text">Completion Variables</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BKL-The-Big-Kernel-Locks"><span class="nav-number">1.0.0.11.</span> <span class="nav-text">BKL: The Big Kernel Locks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sequential-Locks"><span class="nav-number">1.0.0.12.</span> <span class="nav-text">Sequential Locks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Preemption-Disabling"><span class="nav-number">1.0.0.13.</span> <span class="nav-text">Preemption Disabling</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
